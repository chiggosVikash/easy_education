import 'dart:async';

import 'package:easy_education/features/master_setting/data/models/master_setting_model.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/use_cases/master_setting_use_case.dart';

/// A Riverpod provider class that provides settings data for the master settings feature.
///
/// This class extends the generated class _$GetSettingsP, which is generated by the Riverpod package.
/// It provides methods to get and refresh settings data, select a setting, and get the first setting.
///
/// Example usage:
/// ```
/// final getSettingsProvider = Provider<GetSettingsP>((ref) => GetSettingsP());
/// ```
final getSettingsProvider =
    AsyncNotifierProvider.autoDispose<GetSettingsP, List<MasterSettingModel>>(
        () => GetSettingsP());
class GetSettingsP extends AutoDisposeAsyncNotifier<List<MasterSettingModel>> {
  final MasterSettingUseCase _masterSettingUseCase = MasterSettingUseCase();

  @override
  FutureOr<List<MasterSettingModel>> build() {
    return [];
  }

  /// Gets the settings data for the given setting type.
  ///
  /// This method sets the state to AsyncValue.loading() before fetching the data.
  /// If the data is fetched successfully, it sets the state to AsyncValue.data(settings) and returns the settings.
  /// If there is an error while fetching the data, it sets the state to AsyncValue.error(e, StackTrace.current) and returns an empty list.
  Future<List<MasterSettingModel>> getSettings(String settingType) async {
    state = const AsyncValue.loading();
    try {
      final settings =
          await _masterSettingUseCase.getSettings(settingType: settingType);
      state = AsyncValue.data(settings);
      return settings;
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
      if (kDebugMode) {
        rethrow;
      }
      return [];
    }
  }

  /// Refreshes the settings data for the given setting type.
  ///
  /// This method fetches the data and sets the state to AsyncValue.data(settings) if the data is fetched successfully.
  /// If there is an error while fetching the data, it sets the state to AsyncValue.error(e, StackTrace.current).
  Future<void> refreshSettings(String settingType) async {
    try {
      final settings =
          await _masterSettingUseCase.getSettings(settingType: settingType);
      state = AsyncValue.data(settings);
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }

  /// Selects the setting at the given index and returns its name.
  ///
  /// This method sets the isSelected property of the selected setting to true and the isSelected property of all other settings to false.
  /// It then sets the state to AsyncValue.data(settings) and returns the name of the selected setting.
  /// If the state value is null or empty, it returns an empty string.
  String selectSetting(int index) {
    if (state.value == null || state.value!.isEmpty) {
      return "";
    }

    final selectedSetting = state.value![index].name;

    final List<MasterSettingModel> settings = [];

    for (int i = 0; i < state.value!.length; i++) {
      if (index == i) {
        final setting = state.value![i].copyWith(isSelected: true);
        settings.add(setting);
      } else {
        final setting = state.value![i].copyWith(isSelected: false);
        settings.add(setting);
      }
    }

    state = AsyncValue.data(settings);
    return selectedSetting;
  }

  /// Returns the name of the first setting.
  ///
  /// If the state value is null or empty, it returns an empty string.
  String firstClassOrBatch() {
    if (state.value == null || state.value!.isEmpty) {
      return "";
    }
    final firstClassOrBatch = state.value![0].name;
    return firstClassOrBatch;
  }

  /// Returns the selected setting.
  ///
  /// If the state value is null or empty, it returns null.
  /// If there is no selected setting, it returns null.
  MasterSettingModel? selectedSetting() {
    if (state.value == null || state.value!.isEmpty) {
      return null;
    }
    final setting =
        state.value!.where((element) => element.isSelected == true).first;
    return setting;
  }
}
